# 选择排序

## 原理

* 最坏时间复杂度 O(n^2)
* 最优时间复杂度 O(n^2)
* 平均时间复杂度 O(n^2)
* 控件复杂度 O(n)total, O)(1)auxiliary

首先在排序序列中找到最小（大）的元素，存放到排序序列的起始位置，然后，再从生育未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

## 复杂度分析
选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和(n-1)次之间。

比较次数O(n2),比较次数与关键字的初始状态无关，总的比较次数 N = (n-1)+(n-2)+...+1 = nx(n-1)/2。交换次数O(n)，最好的情况是，已经有序，交换0次；最坏的情况是，逆序，交换n-1次。交换次数比冒泡排序少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

原地操作几乎是选择排序的唯一优点，当控件复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。

Code：
```c
template<typename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能
void selection_sort(std::vector<T>& arr) {
	for (int i = 0; i < arr.size() - 1; i++) {
		int min = i;
		for (int j = i + 1; j < arr.size(); j++)
			if (arr[j] < arr[min])
				min = j;
		std::swap(arr[i], arr[min]);
	}
}
```
