# 选择排序

## 原理

* 最坏时间复杂度 O(n^2)
* 最优时间复杂度 O(n^2)
* 平均时间复杂度 O(n^2)
* 控件复杂度 O(n)total, O)(1)auxiliary

首先在排序序列中找到最小（大）的元素，存放到排序序列的起始位置，然后，再从生育未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

Code：
```c
template<typename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能
void selection_sort(std::vector<T>& arr) {
	for (int i = 0; i < arr.size() - 1; i++) {
		int min = i;
		for (int j = i + 1; j < arr.size(); j++)
			if (arr[j] < arr[min])
				min = j;
		std::swap(arr[i], arr[min]);
	}
}
```
