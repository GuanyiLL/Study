# 插入算法

* 最坏时间复杂度 O(n^2)
* 最优时间复杂度 O(n)
* 平均时间复杂度 O(n^2)
* 空间复杂度 总共O(n),需要辅助空间O(1)

## 描述
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2～5

## 算法复杂度
如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好和最坏的情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数减去(n-1)次，（因为(n-1)次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为O(n^2)。

因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序(通常为8个或以下)。

## Code
```c++
void insertion_sort(int arr[], int len) {
  for (int i = 1, j= 0; i < len; ++i) {      //对比len - 1次，直到最后只剩一个数
      int temp = arr[i];    //temp为关键数
      for (j = i - 1; j >= 0 && arr[j] > temp; --j) {      //对比关键数前的所有数
          arr[j + 1] = arr[j];      //找到比关键数大的数值，插入到关键数后面
      }
      arr[j + 1] = temp;      //插入关键数
  }
}
```
