# 希尔排序

希尔排序是基于插入排序的一下两点性质而提出改进方法的：

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。

原始的算法实现在最坏的情况下需要进行O(n^2)的比较和交换。希尔排序通过将比较的全部元素氛围几个区域来提升插入排序的性能。

例如，假设有这样一组数[13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：

> 13  14  94  33  82
>
> 25  59  94  65  23
>
> 45  27  73  25  39
>
> 10

然后对每列进行排序：

> 10  14  73  25  23
>
> 13  27  94  33  39
>
> 25  59  94  65  82
>
> 45

将上述四行数字，依序接在一起时我们得到：[10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45]，这时10已经移至正确位置了，然后再以3为步长进行排序：

> 10 14 73
>
> 25 23 13
>
> 27 94 33
>
> 39  25  59
>
> 94 65 82
>
> 45

排序之后变成

>10 14 13
>
>25 23 33
>
>27 25 59
>
>39 65 73
>
>45 94 82
>
>94

最后以步长进行排序（简单的插入排序）

代码实现：

```c++
void shell_sort(T arr[], int len) {
	int gap, i, j;
	T temp;
	for (gap = len >> 1; gap > 0; gap >>= 1)
		for (i = gap; i < len; i++) {
			temp = arr[i];
			for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap)
				arr[j + gap] = arr[j];
			arr[j + gap] = temp;
		}
}
```
