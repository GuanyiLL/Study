# Sort

* 内部排序：待排序记录存放在计算机存储器中进行的排序过程
* 外部排序：待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中需对外存进行访问的排序过程

内部排序，按排序过程中依据的不同原则大致可以分为插入排序、交换排序、选择排序、归并排序和计数排序等五类；如果按内部排序过程中所需工作量来区分，则可分为三类：

1. 简单的排序方法，时间复杂度为O(n^2)。
2. 先进的排序方法，时间复杂度为O(nlogn)。
3. 基数排序，时间复杂度为O(dn)。

## 插入排序

### 直接插入排序

 算法如下：

 ```c
 void InsertSort(SqList &L) {
     // 对顺序表L作直接插入排序
     for(i = 2; i <= L.length; ++i) {
         if LT(L.r[i].key, L.r[i-1].key) {
             L.r[0] = L.r[i];           // 复制为哨兵
             for (j = i-1; LT(L.r[0].key, L.r[j].key); --j)
                L.r[j+1] = L.r[j];   // 记录后移
             L.r[j+1] = L.r[0];      // 插入到正确位置
         }
     }
 }
 ```

 时间复杂度为O(n^2)

### 其他插入排序

#### 折半插入排序

```c
void BInsertSort(SqList &L) {
    //对顺序表L作折半插入排序
    for (i = 2; i <= L.length; ++i) {
        L.r[0] = L.r[i];
        low = 1; high = i - 1;
        while(low <= high) {
            m = (low + high) / 2;
            if LT(L.r[0].key, L.r[m].key) high = m - 1;
            else low = m + 1;
        }
        for (j = i - 1; j >= high + 1; --j) L.r[j + 1] = L.r[j];
        L.r[high + 1] = L.r[0];
    }
}
```

折半插入所需附加存储空间和直接插入排序相同，从时间上比较，折半插入排序仅减少了关键字间的比较次数，儿记录的移动次数不变。因此时间复杂度仍然为O(n^2)。

#### 2-路插入排序

