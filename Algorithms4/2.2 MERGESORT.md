# 2.2 MERGESORT

快速排序被誉为20世纪科学和工程学的十大算法之一。

**Mergesort.**

* Java对对象进行排序。
* Perl，C ++稳定排序，Python稳定排序，Firefox JavaScript，...

**Quicksort**

* Java对原始类型排序
* C qsort，Unix，Visual C ++，Python，Matlab，Chrome JavaScript，...

## mergesort

将数组分开两半，然后递归排序各自两半，最后再整合到一起。

给出两个已经排好序的子数组`a[lo]`到`a[mid]`和`a[mid+1]`到`a[hi]`，替换为排好序的数组`a[lo]`到`a[hi]`。

merge操作的java实现：

```java
private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {
        assert isSorted(a, lo, mid);  // precondition: a[lo..mid] sorted
        assert isSorted(a, mid+1, hi);// precondition: a[mid+1..hi] sorted
        for (int k = lo; k <= hi; k++)         // copy
            aux[k] = a[k];

        int i = lo, j = mid+1;
        for (int k = lo; k <= hi; k++) {       // merge
            if      (i > mid)              a[k] = aux[j++];
            else if (j > hi)               a[k] = aux[i++];
            else if (less(aux[j], aux[i])) a[k] = aux[j++];
            else                           a[k] = aux[i++];
        }
        assert isSorted(a, lo, hi);  // postcondition: a[lo..hi] sorted
    }
```

**Java assert statement. **除非条件为真，否则抛出异常。

> assert isSorted(a, lo, hi);

**Can enable or disable at runtime. ** ⇒ 不会影响生产代码。

```
java -ea MyProgram // enable assertions
java -da MyProgram // disable assertions (default)
```

整体的排序实现：

```java
public class Merge  {
    private static void merge(...) { /* as before */ }

    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2; 
        sort(a, aux, lo, mid); 
        sort(a, aux, mid+1, hi); 
        merge(a, aux, lo, mid, hi);
    }
    
    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, aux, 0, a.length - 1); 
    }
}
```

**Running time estimates:**

笔记本电脑每秒执行$10^8$次比较。超级计算机每秒执行$10^{12}$次比较。对比如下：

<img src="../img/Algs4/Mergesort/mergesort01.png" alt="mergesort01" style="width:90%;" />

归并排序的时间复杂度

如果 *D*(*N*) 满足 *D*(*N*) = 2 *D*(*N* / 2) + *N* ( *N* > 1), 且 *D*(1) = 0, 则 *D* (*N*) = *N* lg *N*。[假设N为2的证书次幂]

**Proof 1.**  通过图像

<img src="/Users/edz/Desktop/Github/Study/img/Algs4/Mergesort/mergesort02.png" alt="mergesort02" style="width:90%;" />

**Proof2. ** 拓展证明

<img src="../img/Algs4/Mergesort/mergesort03.png" alt="mergesort03" style="width:80%;" />

**Proof3.** 归纳证明

<img src="../img/Algs4/Mergesort/mergesort04.png" alt="mergesort04" style="width:80%;" />

归并排序需要额外的辅助数组来进行排序，因此在空间上不是很完美，现有的挑战则是将归并排序原地进行。

在排序的时候，对太小的数组进行排序开销有些大，如果数组的元素个数大于7个，再使用归并排序。

### 实践优化

如果归并时，左侧数组的最大元素小于右侧数组的最小元素，则不进行排序操作。

```java
private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {
    if (hi <= lo) return;
    int mid = lo + (hi - lo) / 2;
    sort(a, aux, lo, mid);
    sort(a, aux, mid + 1, hi);
    if (!less(a[mid+1], a[mid])) return;
    merge(a, aux, lo, mid, hi);
}
```

## bottom-up mergesort

也可不使用递归来进行排序操作，java实现如下：

```java
private static void merge(...) 
{/*as before*/}

private static void sort(Comparable[] a) {
    int N = a.length;
    Comparable[] aux = new Comparable[N];
    for (int sz = 1; sz < N; sz = sz + sz)
        for (int lo = 0; lo < N - sz; lo += sz + sz)
            merge(a, aux, lo, lo + sz-1,  Math.min(lo + sz + sz - 1,N - 1));
}
```

## stability

如果要对于一组数据，根据不同条目来进行排序，那么第二次排序时，希望在同等key的条目中，保持第一次排序的顺序。

<img src="../img/Algs4/Mergesort/mergesort05.png" alt="mergesort05" style="width:90%;" />

上图中对section排序后，相同的section中，name则变为乱序。以上则称该算法不稳定。

稳定排序：插入排序，归并排序

不稳定排序：选择排序，希尔排序

