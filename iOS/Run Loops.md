# Run Loops

运行循环是与线程关联的基础结构的一部分。运行循环是事件处理循环，可用于计划工作和协调传入事件的接收。运行循环的目的是在有工作要做时让线程忙，而在没有工作时让线程进入睡眠状态。

运行循环管理不是完全自动的。仍然需要设计线程的代码以在适当的时候启动运行循环并响应传入的事件。 Cocoa和Core Foundation都提供运行循环对象，以帮助配置和管理线程的运行循环。开发应用程序时不需要显式创建这些对象。每个线程（包括应用程序的主线程）都有一个关联的运行循环对象。但是，只有辅助线程需要显式地运行其运行循环。在应用程序启动过程中，应用程序框架会自动在主线程上设置并运行运行循环。

## Run Loop解析

运行循环就如同字面表达的意思。是一个让线程进入并且用于处理传入事件响应的循环。您的代码提供了用于实现运行循环实际循环部分的控制语句-换句话说，您的代码提供了驱动运行循环的while或for循环。在循环内，您可以使用运行循环对象来“运行”事件处理代码，以接收事件并调用已安装的处理程序。

运行循环从两种不同类型的源接收事件。输入源传递异步事件，通常是来自另一个线程或其他应用程序的消息。定时器源传递同步事件，这些事件在计划的时间或重复的间隔发生。两种类型的源都使用特定于应用程序的处理程序例程来处理事件到达时的事件。

下图显示了运行循环和各种来源的概念结构。输入源将异步事件传递给相应的处理程序，并调用`runUntilDate：`方法（在线程关联的`NSRunLoop`对象上调用）退出。定时器源将事件传递到其处理程序例程，但不会导致运行循环退出。

![runloop1](/Users/ra1n/Desktop/runloop1.png)

除了处理输入源之外，运行循环还生成有关运行循环行为的通知。 注册的运行循环观察者可以接收这些通知，并使用它们在线程上进行其他处理。 

### Run Loop Modes

运行循环模式是要监视的输入源和定时器的集合，也是被通知的运行循环观察者的集合。每次运行运行循环时，都可以指定运行的特定“模式”。在运行循环的整个过程中，仅监视与该模式关联的源，并允许其传递事件。与其他模式相关联的源将保留任何新事件，直到随后以适当的模式通过该循环。

Cocoa和Core Foundation都定义了默认模式和几种常用模式，以及用于在代码中指定这些模式的字符串。可以为模式名称指定自定义字符串来自定义一个模式。尽管分配给自定义模式的名称是任意的，但是这些模式的内容却不是。必须确保将一个或多个输入源，定时器或运行循环观察者添加到创建的模式中。

可以使用运行循环的模式来过滤不想要的事件。通常我们在系统定义的“默认”模式下使用运行循环。但是有些时候，可能会需要在“模式面板”模式下运行。在这种模式下，只有与模式面板相关的源才将事件传递给线程。对于辅助线程，则可以使用自定义模式来防止低优先级源在时间紧迫的操作期间传递事件。

下表列出了Cocoa和Core Foundation定义的标准模式，以及何时使用该模式的说明。 名称列列出了用于在代码中指定模式的实际常量：

| 模式           | 名称                                                         | 描述                                                         |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Default        | `NSDefaultRunLoopMode` (Cocoa)`kCFRunLoopDefaultMode` (Core Foundation) | 大多数时候，应该使用此模式来启动运行循环并配置输入源。       |
| Connection     | `NSConnectionReplyMode` (Cocoa)                              | Cocoa将此模式与`NSConnection`对象结合使用以监视接收。 几乎不需要自己使用此模式。 |
| Modal          | `NSModalPanelRunLoopMode` (Cocoa)                            | Cocoa使用此模式来识别用于模式面板的事件。                    |
| Event tracking | `NSEventTrackingRunLoopMode` (Cocoa)                         | Cocoa使用此模式来限制鼠标拖动循环和其他类型的用户界面跟踪循环期间的传入事件。 |
| Common modes   | `NSRunLoopCommonModes` (Cocoa)`kCFRunLoopCommonModes` (Core Foundation) | 这是一组常用模式的可配置组。 将输入源与此模式相关联还将其与组中的每个模式相关联。 对于Cocoa应用程序，此集合默认包括Default,Modal和Event tracking模式。 最初，Core Foundation仅包括默认模式。 可以使用`CFRunLoopAddCommonMode`函数将自定义模式添加到集合中。 |

### 输入源

输入源将事件异步传递到线程中。事件的来源取决于输入来源的类型。基于端口的输入源监听应用程序的Mach端口。自定义输入源监听事件的自定义源。就运行循环而言，输入源是基于端口的还是自定义的都无关紧要。系统通常实现两种类型的输入源。两种信号源之间的唯一区别是信号的发送方式。基于端口的源由内核自动发出信号，而自定义源必须从另一个线程手动发出信号。

创建输入源时，可以将其分配给运行循环的一种或多种模式。模式会影响在任何给定时刻监视哪些输入源。大多数情况下会在默认模式下运行运行循环，但也可以使用自定义模式。如果输入源不在当前监听的模式下，则它生成的任何事件都将保留，直到运行循环以正确的模式运行。

#### 基于端口的源

Cocoa和Core Foundation提供了内置支持，用于使用与端口相关的对象和功能创建基于端口的输入源。 例如，在Cocoa中，不需要直接创建输入源。 您只需创建一个端口对象，然后使用NSPort的方法将该端口添加到运行循环中即可。 端口对象为您处理所需输入源的创建和配置。

在Core Foundation中，必须手动创建端口及其运行循环源。 在这两种情况下，都使用与端口不透明类型关联的函数（CFMachPortRef，CFMessagePortRef或CFSocketRef）来创建适当的对象。

有关如何设置和配置基于端口的定制源的示例，请参阅配置基于端口的输入源。 // TODO

#### 自定义输入源

若要创建自定义输入源，必须在Core Foundation中使用与`CFRunLoopSourceRef`不透明类型关联的功能。 通过使用多个回调函数配置自定义输入源。 当从运行循环中删除源时，Core Foundation会在不同位置调用这些函数以配置源，处理所有传入事件并销毁源。

除了定义事件到达时自定义源的行为外，还必须定义事件传递机制。 这一部分源需要在单独的线程上运行，并负责为输入源提供其数据，在准备好处理数据时向其发出信号。 

有关如何创建自定义输入源的示例，请参阅定义自定义输入源。 有关自定义输入源的参考信息，另请参见CFRunLoopSource参考。 // TODO

#### Cocoa Perform Selector Sources

除了基于端口的源代码外，Cocoa还定义了一个自定义输入源，该源可让您在任何线程上执行选择器。

除了基于端口的源代码外，Cocoa还定义了一个自定义输入源，该源可让您在任何线程上执行选择器。 像基于端口的源一样，执行选择器请求在目标线程上被序列化，从而减轻了在一个线程上运行多个方法时可能发生的许多同步问题。 与基于端口的源不同，执行选择器源在执行选择器后将其自身从运行循环中删除。

在另一个线程上执行选择器时，目标线程必须具有活动的运行循环。 对于自己创建的线程，这意味着要一直等到用代码显式启动运行循环。 但是，由于主线程启动了自己的运行循环，因此只要应用程序调用应用程序委托的`applicationDidFinishLaunching:`方法就可以开始在该线程上发出调用。 每次循环中，运行循环都会处理所有排队的执行选择器调用，而不是在每次循环迭代时都处理一个。

下表列出了NSObject上定义的方法，这些方法可用于在其他线程上执行选择器。 由于这些方法是在NSObject上声明的，因此可以在任何有权访问Objective-C对象的线程中使用它们，包括POSIX线程。 这些方法实际上不会创建新线程来执行选择器。

| Methods                                                      | Description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| performSelectorOnMainThread:withObject:waitUntilDone: performSelectorOnMainThread:withObject:waitUntilDone:modes: | 在该线程的下一个运行循环周期内，在该应用程序的主线程上执行指定的选择器。 这些方法使您可以选择阻塞当前线程，直到任务执行完。 |
| performSelector:onThread:withObject:waitUntilDone: performSelector:onThread:withObject:waitUntilDone:modes: | 在具有NSThread对象的任何线程上执行指定的选择器。 这些方法使您可以选择阻塞当前线程，直到任务执行完。 |
| performSelector:withObject:afterDelay: performSelector:withObject:afterDelay:inModes: | 在下一个运行循环周期中以及可选的延迟时间之后，在当前线程上执行指定的选择器。 因为它一直等到下一个运行循环周期执行选择器，所以这些方法提供了当前执行代码的最小自动延迟。 多个排队的选择器按照队列的顺序依次执行。 |
| cancelPreviousPerformRequestsWithTarget: cancelPreviousPerformRequestsWithTarget:selector:object: | 可以将performSelector：withObject：afterDelay：或performSelector：withObject：afterDelay：inModes：发送的消息取消。 |

### 定时器源

定时器源在将来的预设时间将事件同步传递到您的线程。定时器是线程通知自己执行某事的一种方式。例如，一旦在来自用户的连续击键之间经过了一定的时间，然后搜索字段可以使用定时器来启动自动搜索。使用此延迟时间使用户有机会在开始搜索之前键入尽可能多的所需搜索字符串。

尽管定时器生成基于时间的通知，但它不是实时机制。像输入源一样，定时器与运行循环的特定模式相关联。如果定时器不在运行循环当前正在监视的模式下，则只有在以定时器支持的一种模式执行运行循环后，定时器才会触发。同样，如果运行循环在执行处理程序例程的中间触发定时器，则定时器将等到下一次通过运行循环调用其处理例程。如果运行循环根本没有运行，则定时器永远不会触发。

也可以将定时器配置为仅一次或重复生成事件。重复定时器会根据计划的触发时间（而不是实际的触发时间）自动重新计划自身。例如，如果计划将定时器在特定时间触发，然后每5秒触发一次，则即使实际触发时间被延迟，计划的触发时间也将始终落在原始的5秒时间间隔上。如果触发时间延迟得太多，以致错过了一个或多个计划的触发时间，则定时器将在错过的时间段内仅触发一次。在错过了一段时间后触发后，定时器将重新安排为下一个计划的触发时间。

有关配置定时器源的更多信息，请参见配置定时器源。有关参考信息，请参见`NSTimer`类参考或`CFRunLoopTimer`参考。// TODO

### Run Loop 观察者

与在适当的异步或同步事件发生时触发的源相反，运行循环观察者在运行循环本身执行期间的特殊位置才触发。 您可以使用运行循环观察者来准备线程以处理给定事件，或者在线程进入睡眠状态之前准备线程。 您可以将运行循环观察者与运行循环中的以下事件相关联：

- 运行循环的进入。
- 当运行循环将要处理定时器时。
- 当运行循环将要处理输入源时。
- 当运行循环即将进入睡眠状态时。
- 当运行循环被唤醒，但在处理该事件之前将其唤醒。
- 运行循环的退出。

您可以使用Core Foundation将运行循环观察者添加到应用程序。 要创建运行循环观察器，请创建`CFRunLoopObserverRef`的实例。 此类型跟踪自定义回调函数及其关注的活动。

与定时器类似，运行循环观察者可以使用一次或重复使用。 一次触发的观察者在触发后将其从运行循环中删除，而重复的观察者仍保持连接。 可以指定观察者在创建时是运行一次还是重复运行。

有关如何创建运行循环观察者的示例，请参见配置运行循环。 有关参考信息，请参见`CFRunLoopObserver`。

### 事件的运行循环序列

每次运行它时，线程的运行循环都会处理未决事件，并为所有附加的观察者生成通知。 它执行此操作顺序如下：

1. 通知观察者已进入运行循环。
2. 通知观察者任何准备就绪的定时器即将启动。
3. 通知观察者任何不基于端口的输入源都将被触发。
4. 触发所有已准备触发的非基于端口的输入源。
5. 如果基于端口的输入源已准备好并等待启动，请立即处理事件。 转到步骤9。
6. 通知观察者线程即将休眠。
7. 直到发生以下事件之一，使线程进入睡眠状态：
   - 事件到达基于端口的输入源。
   - 定时器启动。
   - 为运行循环设置的超时值到期。
   - 运行循环被明确唤醒。
8. 通知观察者线程刚被唤醒。
9. 处理未决事件。
   - 如果触发了用户定义的计时器，请处理计时器事件并重新启动循环。 转到步骤2。
   - 如果触发了输入源，请传递事件。
   - 如果运行循环已显式唤醒，但尚未超时，请重新启动循环。 转到步骤2。
10. 通知观察者运行循环已退出。

由于定时器和输入源的观察者通知是在这些事件实际发生之前传递的，因此通知时间和实际事件时间之间可能会有偏差。如果这些事件之间的时间很关键，则可以使用睡眠和从睡眠中唤醒通知来关联实际事件之间的时间。

由于在运行运行循环时会传递计时器和其他周期事件，因此应该规避该循环会破坏这些事件的传递。比如每当通过进入循环并且重复从应用程序请求事件来实现鼠标跟踪例程时就会发生。因为代码是直接捕获事件，而不是让应用程序正常分配事件，所以直到鼠标跟踪例程退出并将控制权返回给应用程序之后，定时器才会触发。

可以使用运行循环对象显式唤醒运行循环。其他事件也可能导致运行循环被唤醒。例如，添加另一个非基于端口的输入源将唤醒运行循环，以便可以立即处理输入源，而不是等到其它事件结束。

## 何时使用Run Loop?

唯一需要明确运行运行循环的时间是在为应用程序创建辅助线程时。应用程序主线程的运行循环是基础架构的关键部分。因此，应用程序框架提供了用于运行主应用程序循环并自动启动该循环的代码。如果使用Xcode创建模版项目，则不必用户调用这些例程。

对于辅助线程，需要确定是否需要运行循环，如果需要，请自行配置并启动它。但是无需在所有情况下都启动线程的运行循环。例如，如果使用线程执行一些长时间运行的预定任务，则不用启动运行循环。运行循环用于需要与线程进行更多交互的情况。例如，如果您打算执行以下任一操作，则需要启动运行循环：

- 使用端口或自定义输入源与其他线程进行通信。
- 在线程中使用定时器。
- 在Cocoa中使用任何`performSelector…`方法。
- 保持线程执行周期性任务。

如果确定选择使用运行循环，配置和设置也非常简单。 与所有线程编程一样，您应该有一个计划，在适当的情况下退出辅助线程。 最好让线程自己完成任务结束，而不是强制终止线程。 

## 使用 Run Loop 对象

运行循环对象提供了用于将输入源、计时器和观察者添加到运行循环然后运行它的主界面。 每个线程都有一个与之关联的运行循环对象。 在Cocoa中，此对象是`NSRunLoop`类的实例。 在底层程序中，它是指向`CFRunLoopRef`类型的指针。

### 获取 Run Loop 对象

要获取当前线程的运行循环，请使用以下方法之一：

* 在Cocoa应用程序中，使用`NSRunLoop`的`currentRunLoop`方法获取`NSRunLoop`对象。
* 使用`CFRunLoopGetCurrent`函数。

### 配置 Run Loop

在辅助线程上运行运行循环之前，必须向其添加至少一个输入源或计时器。如果运行循环没有任何要监视的源，则当您尝试运行它时，它将立即退出。有关如何将源添加到运行循环的示例，请参见配置运行循环源。// TODO

除了安装源，还可以安装运行循环观察者，并使用它们来检测运行循环的不同执行阶段。要安装运行循环观察者，请创建`CFRunLoopObserverRef`类型，然后使用`CFRunLoopAddObserver`函数将其添加到运行循环中。即使对于Cocoa应用程序，也必须使用Core Foundation创建运行循环观察者。

下面显示了将运行循环观察程序附加到其运行循环的线程的主例程。该示例的目的是展示如何创建运行循环观察者，因此代码仅设置了一个运行循环观察者以监视所有运行循环活动。基本处理程序例程（未显示）在处理定时器请求时仅记录运行循环活动。

```objectivec
- (void)threadMain {
    // The application uses garbage collection, so no autorelease pool is needed.
    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
 
    // Create a run loop observer and attach it to the run loop.
    CFRunLoopObserverContext  context = {0, self, NULL, NULL, NULL};
    CFRunLoopObserverRef    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
            kCFRunLoopAllActivities, YES, 0, &myRunLoopObserver, &context);
 
    if (observer) {
        CFRunLoopRef    cfLoop = [myRunLoop getCFRunLoop];
        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
    }
 
    // Create and schedule the timer.
    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self
                selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
 
    NSInteger loopCount = 10;
    do {
        // Run the run loop 10 times to let the timer fire.
        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
        loopCount--;
    }
    while (loopCount);
}
```

为了让运行循环生命周期更长，最好添加至少一个输入源以接收消息。 尽管可以只连接一个定时器即可进入运行循环，但是一旦定时器启动，它通常就会失效，这将导致运行循环退出。 附加重复定时器可以使运行循环在更长的时间内运行，但是会涉及定期触发定时器以唤醒线程，这实际上是轮询的另一种形式。 相比之下，输入源会等待事件发生，使线程保持睡眠状态直到事件发生。

### 开启 Run Loop

仅对于程序中的辅助线程才需要启动运行循环。 一个运行循环必须至少有一个输入源或定时器来监视。 如果未连接，则运行循环立即退出。

以下几种方法可以启动运行循环：

* 无条件
* 设定时间限制
* 在特定模式下

无条件进入运行循环是最简单的选择，但也是最不希望的。无条件启动运行循环会将线程置于永久循环，这使得几乎无法控制运行循环本身。可以添加和删除输入源和定时器，但是停止运行循环的唯一方法是终止运行循环。也没有办法在自定义模式下启动运行循环。

与其无条件地运行运行循环，不如使用超时值来启动运行循环。使用超时值时，运行循环将运行直到事件到达或运行到限定时间为止。如果事件到达，则将该事件调度到处理程序进行处理，然后退出运行循环。然后，代码可以重新启动运行循环以处理下一个事件。如果超过分配的时间，则可以简单地重新启动运行循环，或使用该时间进行任何必要的内务处理。

除了超时值之外，还可以使用特定模式启动运行循环。模式和超时值不是互斥的，并且在启动运行循环时都可以使用。模式限制了将事件传递到运行循环的源类型，并且在[Run Loop Modes](#Run Loop Modes)中有更详细的描述。 

以下示例的关键部分显示了运行循环的基本结构。 本质上，将输入源和计时器添加到运行循环，然后重复调用例程之一来启动运行循环。 每次运行循环例程返回时，都要检查是否出现了可能需要退出线程的条件。 该示例使用Core Foundation运行循环例程，以便可以检查返回结果并确定为什么退出运行循环。 如果使用的是Cocoa，则不需要检查返回值，还可以使用NSRunLoop类的方法以类似的方式启动运行循环。 

```objectivec
- (void)skeletonThreadMain
{
    // Set up an autorelease pool here if not using garbage collection.
    BOOL done = NO;
 
    // Add your sources or timers to the run loop and do any other setup.
 
    do {
        // Start the run loop but return after each source is handled.
        SInt32    result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);
 
        // If a source explicitly stopped the run loop, or if there are no
        // sources or timers, go ahead and exit.
        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))
            done = YES;
 
        // Check for any other exit conditions here and set the
        // done variable as needed.
    }
    while (!done);
 
    // Clean up code here. Be sure to release any allocated autorelease pools.
}
```

如果有需要可以递归运行运行循环。 换句话说，可以从输入源或计时器的处理程序例程中调用CFRunLoopRun，CFRunLoopRunInMode或使用任何NSRunLoop方法来启动运行循环。 这样做时，可以使用任何要运行嵌套运行循环的模式，包括外部运行循环使用的模式。

### 退出 Run Loop

在处理事件之前，有两种方法可以使运行循环退出：

* 配置运行循环以超时值运行。
* 告诉运行循环停止。

如果可以管理的很好，使用超时值无疑是首选。 指定超时值可使运行循环在退出之前完成其所有正常处理，包括将通知传递给运行循环观察者。

使用CFRunLoopStop函数停止运行循环会产生类似于超时的结果。 运行循环向所有剩余的运行循环发送消息后然后退出。 区别在于可以在无条件启动的运行循环中使用此技术。

尽管删除运行循环的输入源和计时器也可能导致运行循环退出，但这不是停止运行循环的可靠方法。 一些系统例程将输入源添加到运行循环中以处理所需的事件。 因为代码可能无法意识到这些是输入源，所以它将无法删除它们，这将阻止运行循环退出。

### 线程安全和 Run Loop 对象

线程安全取决于用来操纵运行循环的API。 Core Foundation中的函数通常是线程安全的，可以从任何线程中调用。 但是，如果执行的操作会更改运行循环的配置，则最好还是从拥有运行循环的线程中进行更改。

Cocoa NSRunLoop类本质上不像其Core Foundation对应类那样保证线程安全。 如果使用NSRunLoop类来修改运行循环，则应仅从拥有该运行循环的同一线程进行修改。 将输入源或定时器添加到属于不同线程的运行循环中可能会导致代码崩溃或行为异常。

## 配置 Run Loop 源

### 定义一个自定义输入源

